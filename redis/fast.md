Redis为什么快?

一、底层多种数据结构为数据类型提供支持，在不同的场景下选用最合适的数据结构
动态字符串、跳表、hashmap、双向链表等
二、单线程处理客户端命令,避免了上下文切换及资源的竞争
三、数据存储在内存中，无需从磁盘读取数据减少IO
四、使用IO多路复用处理TCP链接(IO多路复用是处理TCP链接的IO模型，与线程无关)
详见IO.md

Redis主从复制原理
1、从库首次链接到主库时，主库会生成一个RDB快照文件 传输给从库，如果生成快照时 主库收到了写入、修改、删除命令则会在RDB文件传输完成后 通过流式传输到从库
2、第一次全量复制数据完成后，后续的数据是通过主库与从库建立的TCP长连接来进行的，主库会把命令通过Redis自己的数据格式通过TCP长连接传输到从库 也就是流式传输

Redis数据持久化
Redis 提供了两种主要的数据持久化方式：RDB (Redis Database) 快照和 AOF (Append Only File) 日志。

1. RDB (Redis Database) 快照
机制：
RDB 是通过将 Redis 数据集的快照保存到磁盘上的二进制文件来实现的。
Redis 会在指定的时间间隔或在满足特定条件时触发 RDB 快照生成。
RDB 文件可以在 Redis 服务器启动时加载，以恢复 Redis 数据集到快照生成时的状态。

优点：
RDB 文件是一个紧凑的二进制文件，适合用于备份。
RDB 快照生成对 Redis 性能影响较小，因为生成 RDB 文件的过程是由子进程完成的。
缺点：
RDB 不能保证持久化过程中不会丢失数据，尤其是在两次快照之间发生的数据变更。
如果 Redis 服务器崩溃，最后一次快照之后的所有数据变更都会丢失。

2. AOF (Append Only File) 日志
机制：
AOF 是通过将每个写操作记录到日志文件中来实现的。
Redis 服务器会将每个写操作追加到 AOF 文件的末尾，并可以选择对 AOF 文件进行周期性的重写，以压缩日志文件大小。
在 Redis 服务器启动时，可以通过重放 AOF 文件中的写操作日志来恢复数据集。

优点：
AOF 提供更高的数据持久性，因为它可以配置为在每个写操作之后立即进行同步写入（fsync）。
即使 Redis 服务器崩溃，也只会丢失少量数据（取决于 fsync 配置的频率）。

缺点：
AOF 文件比 RDB 文件大，并且重写 AOF 文件的过程会影响 Redis 性能。
如果 AOF 文件过大，重放 AOF 日志以恢复数据集的时间会更长。
组合使用
Redis 允许同时使用 RDB 和 AOF 进行数据持久化：

通过 RDB 文件进行定期备份。
通过 AOF 日志提供更高的持久性保证。
在这种情况下，Redis 在启动时会优先使用 AOF 文件恢复数据，因为 AOF 文件包含更完整的数据集。

Redis内存淘汰

可以通过 maxmemory-policy 配置项设置 Redis 的缓存淘汰策略。以下是 Redis 支持的几种常见淘汰策略：

noeviction:
当达到最大内存限制时，不再执行驱逐策略，直接返回错误。
适用于希望严格控制内存使用的场景。
allkeys-lru:
基于最近最少使用 (Least Recently Used, LRU) 算法，淘汰最久未使用的键。
在所有键中选择最久未使用的键进行驱逐。
volatile-lru:
基于 LRU 算法，在设置了过期时间的键中选择最久未使用的键进行驱逐。
不会驱逐没有设置过期时间的键。
allkeys-random:
随机选择键进行驱逐。
在所有键中随机选择进行驱逐。
volatile-random:
随机选择键进行驱逐。
在设置了过期时间的键中随机选择进行驱逐。
volatile-ttl:
基于剩余存活时间 (Time To Live, TTL) 的算法，驱逐最接近过期的键。
仅在设置了过期时间的键中进行选择。
volatile-lfu:
基于最近最少使用 (Least Frequently Used, LFU) 算法，在设置了过期时间的键中选择最少使用的键进行驱逐。
allkeys-lfu:
基于 LFU 算法，在所有键中选择最少使用的键进行驱逐。

选择合适的淘汰策略
选择合适的淘汰策略取决于具体应用的需求和特点：

如果所有数据都很重要且不希望丢失，选择 noeviction。
如果应用中所有数据都重要，且希望尽可能缓存最多的数据，选择 allkeys-lru 或 allkeys-lfu。
如果只希望驱逐有过期时间的缓存数据，选择 volatile-lru、volatile-lfu、volatile-ttl 或 volatile-random。
通过合理配置最大内存限制和淘汰策略，可以确保 Redis 在内存限制内高效运行，同时满足应用的缓存需求。


集群的三种类型：

1. **一主多从**：
   - 在这种模式下，每个主节点可以有多个从节点。主节点负责处理写请求，从节点负责处理读请求。
   - 数据从主节点同步到从节点，主节点挂掉时，需要手动切换主节点。

2. **多主多从**：
   - 每个主节点都有多个从节点，并且系统支持多个主节点，每个主节点处理一部分数据。
   - 数据在主节点之间同步，以实现数据分片和负载均衡。
   - 这种模式可以提供更高的可用性和扩展性，但也会增加系统复杂性。

3. **哨兵模式**：
   - 哨兵模式主要用于监控 Redis 实例的状态，自动故障转移以及提供高可用性。
   - 哨兵实例监控主节点的健康状况，并在主节点出现故障时，自动选举新的主节点。
   - 哨兵实例不保存数据，仅用于监控和故障转移。

## 主从模式的数据同步

无论是“一主多从”还是“多主多从”的模式，主从间的数据同步机制如下：

1. **全量复制**：
   - 当从节点首次连接到主节点时，主节点会将所有数据以 RDB 文件的形式发送给从节点，这个过程称为全量复制。

2. **增量复制**：
   - 在全量复制完成后，主节点会持续将更新操作（写命令）发送给从节点，这个过程称为增量复制。
   - 增量复制通过传输主节点的写命令日志实现。

## 主从模式与哨兵模式的区别

1. **主从模式**：
   - 主要用于数据的复制和负载均衡。
   - 主节点处理所有写请求，从节点处理读请求。
   - 数据同步是单向的，从主节点到从节点。

2. **哨兵模式**：
   - 主要用于提供高可用性和自动故障转移。
   - 监控 Redis 实例的状态，并在主节点出现故障时自动切换主节点。
   - 哨兵实例本身不保存数据，负责监控和管理主从节点。

## 哨兵实例的资源消耗

1. **资源占用**：
   - 哨兵实例的资源消耗相对较小，主要用于监控和故障转移，不涉及大量的数据存储。
   - 哨兵实例需要额外的计算资源，但这些资源相对较少。

2. **高可用性**：
   - 哨兵实例确保 Redis 集群的高可用性和自动故障转移，避免了单点故障带来的停机风险。
   - 在大规模的部署中，多个哨兵实例提供更高的容错能力。

3. **资源节省策略**：
   - 可以通过资源共享、虚拟化和容器化技术来优化资源使用。
   - 调整哨兵实例的配置和使用自动扩展功能可以减少资源浪费。

## 总结

专门为 Redis 配置哨兵实例虽然会消耗额外的资源，但对于确保系统的高可用性和自动故障转移是非常重要的。合理配置和资源优化可以有效地减少资源浪费，同时保持系统的高可用性。













