Redis为什么快?

一、底层多种数据结构为数据类型提供支持，在不同的场景下选用最合适的数据结构
动态字符串、跳表、hashmap、双向链表等
二、单线程处理客户端命令,避免了上下文切换及资源的竞争
三、数据存储在内存中，无需从磁盘读取数据减少IO
四、使用IO多路复用处理TCP链接(IO多路复用是处理TCP链接的IO模型，与线程无关)
详见IO.md

Redis主从复制原理
1、从库首次链接到主库时，主库会生成一个RDB快照文件 传输给从库，如果生成快照时 主库收到了写入、修改、删除命令则会在RDB文件传输完成后 通过流式传输到从库
2、第一次全量复制数据完成后，后续的数据是通过主库与从库建立的TCP长连接来进行的，主库会把命令通过Redis自己的数据格式通过TCP长连接传输到从库 也就是流式传输

Redis数据持久化
Redis 提供了两种主要的数据持久化方式：RDB (Redis Database) 快照和 AOF (Append Only File) 日志。

1. RDB (Redis Database) 快照
机制：
RDB 是通过将 Redis 数据集的快照保存到磁盘上的二进制文件来实现的。
Redis 会在指定的时间间隔或在满足特定条件时触发 RDB 快照生成。
RDB 文件可以在 Redis 服务器启动时加载，以恢复 Redis 数据集到快照生成时的状态。

优点：
RDB 文件是一个紧凑的二进制文件，适合用于备份。
RDB 快照生成对 Redis 性能影响较小，因为生成 RDB 文件的过程是由子进程完成的。
缺点：
RDB 不能保证持久化过程中不会丢失数据，尤其是在两次快照之间发生的数据变更。
如果 Redis 服务器崩溃，最后一次快照之后的所有数据变更都会丢失。

2. AOF (Append Only File) 日志
机制：
AOF 是通过将每个写操作记录到日志文件中来实现的。
Redis 服务器会将每个写操作追加到 AOF 文件的末尾，并可以选择对 AOF 文件进行周期性的重写，以压缩日志文件大小。
在 Redis 服务器启动时，可以通过重放 AOF 文件中的写操作日志来恢复数据集。

优点：
AOF 提供更高的数据持久性，因为它可以配置为在每个写操作之后立即进行同步写入（fsync）。
即使 Redis 服务器崩溃，也只会丢失少量数据（取决于 fsync 配置的频率）。

缺点：
AOF 文件比 RDB 文件大，并且重写 AOF 文件的过程会影响 Redis 性能。
如果 AOF 文件过大，重放 AOF 日志以恢复数据集的时间会更长。
组合使用
Redis 允许同时使用 RDB 和 AOF 进行数据持久化：

通过 RDB 文件进行定期备份。
通过 AOF 日志提供更高的持久性保证。
在这种情况下，Redis 在启动时会优先使用 AOF 文件恢复数据，因为 AOF 文件包含更完整的数据集。

Redis内存淘汰

可以通过 maxmemory-policy 配置项设置 Redis 的缓存淘汰策略。以下是 Redis 支持的几种常见淘汰策略：

noeviction:
当达到最大内存限制时，不再执行驱逐策略，直接返回错误。
适用于希望严格控制内存使用的场景。
allkeys-lru:
基于最近最少使用 (Least Recently Used, LRU) 算法，淘汰最久未使用的键。
在所有键中选择最久未使用的键进行驱逐。
volatile-lru:
基于 LRU 算法，在设置了过期时间的键中选择最久未使用的键进行驱逐。
不会驱逐没有设置过期时间的键。
allkeys-random:
随机选择键进行驱逐。
在所有键中随机选择进行驱逐。
volatile-random:
随机选择键进行驱逐。
在设置了过期时间的键中随机选择进行驱逐。
volatile-ttl:
基于剩余存活时间 (Time To Live, TTL) 的算法，驱逐最接近过期的键。
仅在设置了过期时间的键中进行选择。
volatile-lfu:
基于最近最少使用 (Least Frequently Used, LFU) 算法，在设置了过期时间的键中选择最少使用的键进行驱逐。
allkeys-lfu:
基于 LFU 算法，在所有键中选择最少使用的键进行驱逐。

选择合适的淘汰策略
选择合适的淘汰策略取决于具体应用的需求和特点：

如果所有数据都很重要且不希望丢失，选择 noeviction。
如果应用中所有数据都重要，且希望尽可能缓存最多的数据，选择 allkeys-lru 或 allkeys-lfu。
如果只希望驱逐有过期时间的缓存数据，选择 volatile-lru、volatile-lfu、volatile-ttl 或 volatile-random。
通过合理配置最大内存限制和淘汰策略，可以确保 Redis 在内存限制内高效运行，同时满足应用的缓存需求。












